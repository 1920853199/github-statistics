{"version":3,"sources":["reducers/github.js","reducers/index.js","components/DataTypes.js","components/sections/Colors.js","scripts/GithubFetcher.js","components/sections/Repository.js","components/sections/ChartOptions.js","components/sections/Star.js","components/sections/Fork.js","components/sections/Commit.js","components/sections/Release.js","components/DataSection.js","components/GithubStatistics.js","actions/github.js","components/App.js","serviceWorker.js","index.js"],"names":["INITIAL_STATE","repoData","repoStats","starData","starStats","forkData","forkStats","releaseData","releaseStats","githubApiToken","github","state","action","type","payload","data","Object","assign","stats","reducers","combineReducers","REPO","STAR","FORK","COMMIT","RELEASE","getProgress","c","t","Math","floor","GithubFetcher","token","searchRepository","input","onResult","a","variables","query","formattedData","gqlClient","request","search","nodes","forEach","repo","push","nameWithOwner","fetchRepositoryData","owner","name","onUpdate","onFinish","onProgress","shouldAbort","repository","createdAt","primaryLanguage","pushedAt","watcherCount","watchers","totalCount","fetchStargazerData","preparationVariables","preparationQuery","Map","pageIndex","totalToFetch","maxIncrement","numberFetched","previousEndCursor","hasNextPage","preparationData","stargazers","handleEdge","edge","date","Date","starredAt","slice","getTime","has","set","get","edges","pageInfo","endCursor","liveUpdate","pagesPerUpdate","total","fetchForkData","forks","handleNode","node","fetchCommitData","defaultBranchRef","target","history","headRefOid","oid","since","committedDate","setFullYear","getFullYear","toISOString","object","fetchReleaseData","totalDownloads","releases","releaseAssets","asset","id","updatedAt","contentType","downloadCount","totalAssets","tagName","this","GraphQLClient","headers","Authorization","Repository","_render","props","ready","Array","from","entries","map","pair","index","dateSinceCreated","now","valueOf","key","color","COLORS","align","justify","className","title","value","toDateString","moment","fromNow","prefix","React","Component","text","undefined","legend","itemStyle","fontWeight","colors","tooltip","shadow","split","credits","enabled","Star","_renderStatistics","averagePerDay","precision","_renderCharts","values","includes","highcharts","Highcharts","options","OPTIONS","chart","zoomType","xAxis","yAxis","gridLineWidth","series","dataArray","nextProps","loading","formatter","increment","cumulativeCount","Fork","Commit","reverse","Release","averageDownloadsPerDay","columns","dataSource","pagination","dataIndex","render","time","format","DataSection","_fetch","repos","slashIndex","indexOf","fetchCall","setState","_getAllProgress","progress","reduce","b","size","_renderUpdateAllButton","icon","disabled","length","onClick","_renderRepoTags","visible","style","display","percent","showInfo","strokeWidth","width","checked","onChange","_renderBody","body","fetcher","TYPES","fontSize","info","console","log","prevProps","deleteRepo","delete","filter","content","placement","marginLeft","connect","GithubStatistics","splice","addRepo","message","error","_renderTags","closable","onClose","rel","href","_renderHeaderInput","testingRepo","suggestions","hintMessage","inputEmpty","repoExisted","Fragment","placeholder","defaultActiveFirstOption","onSearch","notFoundContent","showArrow","filterOption","showSearch","Option","updateState","_","debounce","leading","trailing","bind","src","frameBorder","scrolling","height","bounds","Link","dispatch","App","Boolean","window","location","hostname","match","store","createStore","ReactDOM","document","getElementById","navigator","serviceWorker","then","registration","unregister"],"mappings":"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","file":"static/js/main.dc405b77.chunk.js","sourcesContent":["const INITIAL_STATE = {\n  repoData: [],\n  repoStats: {},\n\n  starData: [],\n  starStats: {},\n\n  forkData: [],\n  forkStats: {},\n\n  releaseData: [],\n  releaseStats: {},\n\n  githubApiToken: '05c1acf261f6b223411c73d8b71cb1a30ce9186a',\n\n}\n\nconst github = (state = INITIAL_STATE, action) => {\n  const { type, payload } = action\n  switch (type) {\n    case 'UPDATE_STATE':\n      return {\n        ...state,\n        ...{[payload.state]: payload.data}\n      }\n    case 'UPDATE_STATS_FIELD':\n      return Object.assign({}, state, {\n        [payload.state] : {\n          ...state[payload.state],\n          ...payload.stats\n        }\n      })\n    default:\n      return state\n  }\n}\n\nexport default github","import { combineReducers } from 'redux'\n\nimport github from './github'\n\nconst reducers = combineReducers({\n  github: github,\n})\n\nexport default reducers","/**\n * Keys are used for reference\n * Values are used for displaying and passing\n */\n\nexport default {\n  REPO: 'Repository',\n  STAR: 'Star',\n  FORK: 'Fork',\n  COMMIT: 'Commit',\n  RELEASE: 'Release',\n}","export default [\n  '#A2B449',\n  '#E89A41',\n  '#9EABCD',\n  '#56BABD',\n  '#D79AB3',\n  '#E6978A',\n  '#5EBE85',\n]","import {  } from 'graphql'\nimport { GraphQLClient } from 'graphql-request'\n\nconst getProgress = (c, t) => t === 0 ? 100 : Math.floor(c / t * 100)\n\nclass GithubFetcher {\n\n  constructor(token) {\n    const endpoint = 'https://api.github.com/graphql'\n\n    this.gqlClient = new GraphQLClient(\n      endpoint,\n      {\n        headers: {\n          Authorization: 'bearer ' + token,\n        }\n      }\n    )\n\n    // configurations\n    this.liveUpdate = false\n    this.pagesPerUpdate = 20\n  }\n\n  /**\n   * test if the repository exists\n   * @param owner owner of the repository\n   * @param name of the repository\n   * @param onResult (@param result) function that will be called when test finishes\n   * @return false if not exist, true otherwise\n   */\n  // testRepository = async (owner, name, onResult) => {\n  //   const variables = {\n  //     owner: owner,\n  //     name: name,\n  //   }\n\n  //   const query = /* GraphQL */ `\n  //     query getRepository($owner: String!, $name: String!){\n  //       repository(owner: $owner, name: $name) {\n  //         id\n  //       }\n  //     }\n  //   `\n\n  //   try {\n  //     await this.gqlClient.request(query, variables)\n  //   } catch (error) {\n  //     if (onResult) {\n  //       onResult(false)\n  //     }\n  //     return false\n  //   }\n\n  //   if (onResult) onResult(true)\n  //   return true\n  // }\n\n  /**\n   * suggest possible repositories based on current input\n   * @param onResult (@param result) function that will be called when search finishes\n   */\n  searchRepository = async (input, onResult) => {\n    const variables = {\n      query: input,\n    }\n\n    const query = /* GraphQL */ `\n      query searchRepository($query: String!){\n        search(query: $query, first: 5, type: REPOSITORY) {\n          codeCount\n          nodes {\n            ...on Repository {\n              nameWithOwner\n            }\n          }\n        }\n      }\n    `\n    let formattedData = []\n\n    const data = await this.gqlClient.request(query, variables)\n\n    data.search.nodes.forEach(repo => formattedData.push(repo.nameWithOwner))\n\n    if (onResult) onResult(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchRepositoryData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRepository($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          nameWithOwner\n          createdAt\n          primaryLanguage {\n            name\n          }\n          pushedAt\n          watchers(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n\n    // update progress tracking\n    if (onProgress) onProgress(10)\n\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n\n    const formattedData = {\n      name: data.repository.nameWithOwner,\n      createdAt: data.repository.createdAt,\n      primaryLanguage: data.repository.primaryLanguage.name,\n      pushedAt: data.repository.pushedAt,\n      watcherCount: data.repository.watchers.totalCount,\n    }\n\n    // update progress tracking\n    if (onProgress) onProgress(100)\n\n    if (onFinish) onFinish(formattedData)\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchStargazerData = async (owner, name, onUpdate = () => {}, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareStargazers($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          stargazers(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getStargazers($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          stargazers(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            edges {\n              starredAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.stargazers.totalCount\n    const createdAt = preparationData.repository.createdAt\n\n    const handleEdge = edge => {\n      const date = new Date(edge.starredAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.stargazers.edges.forEach(handleEdge)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.stargazers.pageInfo.endCursor\n      hasNextPage = data.repository.stargazers.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch fork data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchForkData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareForks($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          createdAt\n          forkCount\n          forks(first: 0) {\n            totalCount\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getForks($owner: String!, $name: String!, $previousEndCursor: String){\n        repository(owner: $owner, name: $name) {\n          forks(first: 100, after: $previousEndCursor) {\n            pageInfo {\n              endCursor\n              hasNextPage\n            }\n            nodes {\n              createdAt\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let maxIncrement = 0\n    let numberFetched = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.forks.totalCount\n    const createdAt = preparationData.repository.createdAt\n    \n\n\n    const handleNode = node => {\n      const date = new Date(node.createdAt.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      data.repository.forks.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.forks.pageInfo.endCursor\n      hasNextPage = data.repository.forks.pageInfo.hasNextPage\n\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch repository low-level data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchCommitData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const preparationVariables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const preparationQuery = /* GraphQL */ `\n      query prepareCommits($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n          defaultBranchRef {\n            # name\n            target {\n              ... on Commit {\n                oid\n                committedDate\n                history {\n                  totalCount\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n    const query = /* GraphQL */ `\n      query getCommits($owner: String!, $name: String!, $previousEndCursor: String, $oid: GitObjectID!, $since: GitTimestamp!){\n        repository(owner: $owner, name: $name) {\n          object(oid: $oid) {\n            ... on Commit {\n              history(first: 100, after: $previousEndCursor, since: $since ) {\n                totalCount\n                pageInfo {\n                  endCursor\n                  hasNextPage\n                }\n                nodes {\n                  committedDate\n                  # message\n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n\n    // local variables\n    const formattedData = new Map()\n    let pageIndex = 0\n    let totalToFetch = 0\n    let numberFetched = 0\n    let maxIncrement = 0\n    let previousEndCursor = null\n    let hasNextPage = false\n\n    // Preparation query\n    const preparationData = await this.gqlClient.request(preparationQuery, preparationVariables)\n\n    // from preparation\n    totalToFetch = preparationData.repository.defaultBranchRef.target.history.totalCount\n    const headRefOid = preparationData.repository.defaultBranchRef.target.oid\n    const since = new Date(new Date(preparationData.repository.defaultBranchRef.target.committedDate)\n      .setFullYear(new Date(preparationData.repository.defaultBranchRef.target.committedDate).getFullYear() - 1))\n      .toISOString()\n\n    const handleNode = node => {\n      const date = new Date(node.committedDate.slice(0,10)).getTime() // ISO-8601 encoded UTC date string\n      if (!formattedData.has(date)) {\n        formattedData.set(date, 1)\n      } else {\n        formattedData.set(date, formattedData.get(date) + 1)\n      }\n      if (formattedData.get(date) > maxIncrement) maxIncrement = formattedData.get(date)\n      // update progress tracking\n      numberFetched += 1\n    }\n\n    // data traversal, 100 edges/request\n    do {\n      if (shouldAbort) if (shouldAbort()) return\n\n      const variables = {\n        owner: owner,\n        name: name,\n        oid: headRefOid,\n        since: since,\n        previousEndCursor: previousEndCursor\n      }\n      // query for data\n      const data = await this.gqlClient.request(query, variables)\n\n      totalToFetch = data.repository.object.history.totalCount\n      data.repository.object.history.nodes.forEach(handleNode)\n\n      // update progress tracking\n      if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n\n      // track loop-level variables\n      previousEndCursor = data.repository.object.history.pageInfo.endCursor\n      hasNextPage = data.repository.object.history.pageInfo.hasNextPage\n      // update pageIndex\n      pageIndex += 1\n\n      // onUpdate callback if existed\n      if (this.liveUpdate && onUpdate && pageIndex % this.pagesPerUpdate === 0) {\n        onUpdate(formattedData)\n      }\n    } while (hasNextPage)\n\n    if (onUpdate) onUpdate(formattedData)\n    if (onFinish) onFinish({\n      total: totalToFetch,\n      maxIncrement,\n      createdAt: since,\n    })\n\n    return formattedData\n  }\n\n  /**\n   * fetch release data\n   * @param owner owner of the repository\n   * @param name name of the repository\n   * @param onUpdate (data) function that will be called when a new data update is avaiable\n   * @param onFinish (stats) function that will be called when fetching is finished\n   * @param onProgress (progress) function that will be called when progress is updated\n   * @param shouldAbort function that returns a boolean which determines whether fetching should abort\n   * @returns Object that contains statistics\n   */\n  fetchReleaseData = async (owner, name, onUpdate, onFinish, onProgress, shouldAbort) => {\n    const variables = {\n      owner: owner,\n      name: name,\n    }\n\n    // define the graphql query\n    const query = /* GraphQL */ `\n      query getRelease($owner: String!, $name: String!){\n        repository(owner: $owner, name: $name) {\n          releases(first: 1, orderBy:{field:CREATED_AT,direction: DESC}) {\n            totalCount\n            nodes {\n              name\n              tagName\n              createdAt\n              releaseAssets (first: 20) {\n                totalCount\n                nodes {\n                  id\n                  name\n                  updatedAt\n                  contentType\n                  createdAt\n                  downloadCount\n                  \n                }\n              }\n            }\n          }\n        }\n      }\n    `\n\n    // local variables\n    const formattedData = []\n    let totalToFetch = 0\n    let numberFetched = 0\n    let totalDownloads = 0\n\n    // Preparation query\n    const data = await this.gqlClient.request(query, variables)\n    // if (shouldAbort) {\n    //   if (shouldAbort()) {\n    //     return\n    //   }\n    // }\n\n    if (data.repository.releases.totalCount !== 0) {\n      // from preparation\n      totalToFetch = data.repository.releases.nodes[0].releaseAssets.totalCount\n\n      // get stats of each asset\n      data.repository.releases.nodes[0].releaseAssets.nodes.forEach(asset => {\n        formattedData.push({\n          id: asset.id,\n          name: asset.name,\n          updatedAt: asset.updatedAt,\n          contentType: asset.contentType,\n          createdAt: asset.createdAt,\n          downloadCount: asset.downloadCount,\n        })\n\n        totalDownloads += asset.downloadCount\n\n        numberFetched += 1\n        if (onProgress) onProgress(getProgress(numberFetched, totalToFetch))\n      })\n\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n        name: data.repository.releases.nodes[0].name,\n        tagName: data.repository.releases.nodes[0].tagName,\n        createdAt: data.repository.releases.nodes[0].createdAt\n      })\n    } else {\n      if (onProgress) onProgress(100)\n\n      if (onUpdate) onUpdate(formattedData)\n\n      if (onFinish) onFinish({\n        totalAssets: totalToFetch,\n        totalDownloads: totalDownloads,\n      })\n    }\n\n    return formattedData\n  }\n}\n\nexport default GithubFetcher","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Repository extends React.Component {\n\n  _render = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { name, createdAt, primaryLanguage, pushedAt, watcherCount } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n\n            return (\n              <div key={`repo-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Repository\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Date created\" value={new Date(createdAt).toDateString()} />                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Days since created\" value={dateSinceCreated} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Primary language\" value={primaryLanguage} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Last push at\" value={moment(pushedAt).fromNow()} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Watchers\" prefix={<Icon type=\"eye\"/>} value={watcherCount} />\n                  </span>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nRepository.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Repository","/**\n * Common highchart options shared by\n * most of the charts\n */\n\nimport COLORS from './Colors'\n\nexport default {\n  title: {\n    text: undefined,\n  },\n  // xAxis: {\n  //   type: 'datetime',\n  // },\n  legend: {\n    itemStyle: {\n      color: 'rgba(0, 0, 0, 0.85)',\n      fontWeight: '300'\n    }\n  },\n  colors: COLORS,\n  tooltip: {\n    shadow: false,\n    split: true,\n  },\n  credits: {\n    enabled: false,\n  },\n}","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Star extends React.Component {\n  static formatter = (repo, data) => {\n    // star total data, index 0\n    let total = { name: repo, data: [] }\n    // star  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`star-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total stars\" value={total} prefix={<Icon type=\"star\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. stars/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. stars/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'line',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total stars',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'star increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  // _renderLines = (dataIndex) => {\n  //   const { data, ready } = this.props\n  //   const dataReady = Array.from(ready.values())\n  //   console.log(\"Lines are rendered\")\n  //   return Array.from(data.values()).map((dataArray, index) => (\n  //     dataReady[index]\n  //       ?\n  //       <Line\n  //         type=\"monotone\"\n  //         key={`star-chart-total-${dataArray[dataIndex].name}`}\n  //         data={dataArray[dataIndex].data}\n  //         dataKey=\"value\"\n  //         name={dataArray[dataIndex].name}\n  //         stroke={COLORS[index]}\n  //         dot={false}\n  //       />\n  //       :\n  //     <></>\n  //   ))\n  // }\n\n  // _renderCharts = () => {\n  //   const { ready } = this.props\n\n  //   if (!Array.from(ready.values()).includes(true)) return\n\n  //   return (\n  //     <>\n  //     <Row>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'total stars', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(0)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //       <div>\n  //         <ResponsiveContainer width=\"100%\" height={300}>\n  //           <LineChart>\n  //             <CartesianGrid stroke=\"#ccc\" strokeDasharray=\"2 7\" />\n  //             <Legend verticalAlign=\"top\"/>\n  //             <XAxis\n  //               dataKey=\"timestamp\"\n  //               scale=\"time\"\n  //               allowDuplicatedCategory={false}\n  //               type=\"number\"\n  //               domain = {['auto', 'auto']}\n  //               tickFormatter={ms => new Date(ms).toISOString().slice(0,10)}\n  //             />\n  //             <YAxis dataKey=\"value\" label={{ value: 'daily increment', angle: -90, position: 'insideBottomLeft' }}/>\n  //             <ChartToolTip labelFormatter={ms => new Date(ms).toISOString().slice(0,10)}/>\n  //             {this._renderLines(1)}\n  //           </LineChart>\n  //         </ResponsiveContainer>\n  //       </div>\n  //     </Row>\n  //     </>\n  //   )\n  // }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nStar.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Star","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Fork extends React.Component {\n  static formatter = (repo, data) => {\n    // fprk total data, index 0\n    let total = { name: repo, data: [] }\n    // fork  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n    data.forEach((value, key) => {\n      cumulativeCount += value\n      total.data.push([key, cumulativeCount])\n      increment.data.push([key, value])\n    })\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total forks\" value={total} prefix={<Icon type=\"fork\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. forks/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. forks/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'line',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total forks',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'fork increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nFork.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Fork","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { Row, Statistic, Icon, Tag } from 'antd'\n// import { LineChart, Line, CartesianGrid, XAxis, YAxis, ResponsiveContainer, Legend, Tooltip as ChartToolTip } from 'recharts'\nimport Highcharts from 'highcharts'\nimport HighchartsReact from 'highcharts-react-official'\n\nimport COLORS from './Colors'\nimport OPTIONS from './ChartOptions'\n\n\nclass Commit extends React.Component {\n  static formatter = (repo, data) => {\n    // commit total data, index 0\n    let total = { name: repo, data: [] }\n    // commit  daily increment data, index 1\n    let increment = { name: repo, data: [] }\n\n    let cumulativeCount = 0\n\n    // traversal backwards\n    Array.from(data.entries()).slice().reverse().forEach(\n      pair => {\n        cumulativeCount += pair[1]\n        total.data.push([pair[0], cumulativeCount])\n        increment.data.push([pair[0], pair[1]])\n      }\n    )\n\n    return [total, increment]\n  }\n\n  shouldComponentUpdate(nextProps) {\n    return !nextProps.loading && !Array.from(nextProps.ready.values()).includes(false)\n  }\n\n  _renderStatistics = () => {\n    const { stats, ready } = this.props\n\n    return (\n      <>\n      {Array.from(stats.entries()).map((\n        (pair, index) => {\n          if (ready.get(pair[0])) {\n            const { total, maxIncrement, createdAt } = pair[1]\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averagePerDay = total / dateSinceCreated\n            return (\n              <div key={`fork-statistics-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                  <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Total commits\" value={total} prefix={<Icon type=\"history\" />} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Avg. commits/day\" value={averagePerDay} precision={2} />\n                    </span>\n                    <span className=\"stats-card\">\n                      <Statistic title=\"Max. commits/day\" value={maxIncrement} />\n                    </span>\n                  </Row>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  _renderCharts = () => {\n    const { data, ready } = this.props\n\n    if (!Array.from(ready.values()).includes(true)) return\n\n    return (\n      <>\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'line',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'total commits',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[0]),\n        }}\n      />\n      <HighchartsReact\n        highcharts={Highcharts}\n        options={{ ...OPTIONS,\n          chart: {\n            type: 'column',\n            zoomType: 'x',\n          },\n          xAxis: {\n            type: 'datetime',\n          },\n          yAxis: {\n            gridLineWidth: 0,\n            title: {\n              text: 'commit increment/day',\n            },\n          },\n          series: Array.from(data.values()).map(dataArray => dataArray[1]),\n        }}\n      />\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._renderStatistics()}\n      {this._renderCharts()}\n      </>\n    )\n  }\n}\n\nCommit.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n  loading: PropTypes.bool,\n}\n\n\nexport default Commit","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport moment from 'moment'\n\nimport { Row, Statistic, Icon, Tag, Table } from 'antd'\n\nimport COLORS from './Colors'\n\nclass Release extends React.Component {\n\n  _render = () => {\n    const { stats, data, ready } = this.props\n\n    return (\n      <>\n      {Array.from(ready.entries()).map((\n        (pair, index) => {\n          if (pair[1]) { // ready\n            const { totalAssets, name, tagName, createdAt, totalDownloads } = stats.get(pair[0])\n\n            const dateSinceCreated = Math.floor((Date.now() - new Date(createdAt).valueOf()) / (24*60*60*1000))\n            const averageDownloadsPerDay = totalDownloads / dateSinceCreated\n\n            return (\n              <div key={`release-${pair[0]}`}>\n                <Row>\n                  <Tag color={COLORS[index]}>\n                    {pair[0]}\n                  </Tag>\n                </Row>\n                <Row type=\"flex\" align=\"middle\" justify=\"space-between\">\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release tag\" value={tagName} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Release name\" value={name} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total assets\" value={totalAssets} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Total asset downlaods\" value={totalDownloads} prefix={<Icon type=\"download\"/>} />\n                  </span>\n                  <span className=\"stats-card\">\n                    <Statistic title=\"Avg. downloads/day\" value={averageDownloadsPerDay} precision={2} />\n                  </span>\n                </Row>\n                <Row>\n                  <Table columns={columns} dataSource={data.get(pair[0])} pagination={false}/>\n                </Row>\n              </div>\n            )\n          }\n          return false\n        }\n      ))}\n      </>\n    )\n  }\n\n  render() {\n    return (\n      <>\n      {this._render()}\n      </>\n    )\n  }\n}\n\nconst columns = [\n  {\n    title: 'Asset',\n    dataIndex: 'name',\n    key: 'name',\n  },\n  {\n    title: 'Content type',\n    dataIndex: 'contentType',\n    key: 'contentType',\n  },\n  {\n    title: 'Downloads',\n    dataIndex: 'downloadCount',\n    key: 'downloadCount',\n  },\n  {\n    title: 'Created at',\n    dataIndex: 'createdAt',\n    key: 'createdAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n  {\n    title: 'Updated at',\n    dataIndex: 'updatedAt',\n    key: 'updatedAt',\n    render: time => moment(time).format(\"MMMM Do YYYY, h:mm:ss a\")\n  },\n\n]\n\n\nRelease.propTypes = {\n  id: PropTypes.string,\n  repos: PropTypes.array,\n  data: PropTypes.objectOf(Map),\n  stats: PropTypes.objectOf(Map),\n  ready: PropTypes.objectOf(Map),\n}\n\n\nexport default Release","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\n// import _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport '../css/DataSection.css'\n\nimport { Progress, Button, Row, Icon, Tag, Popover } from 'antd'\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport Repository from './sections/Repository'\nimport Star from './sections/Star'\nimport Fork from './sections/Fork'\nimport Commit from './sections/Commit'\nimport Release from './sections/Release'\n\nclass DataSection extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      progress: new Map(),\n      data: new Map(),\n      stats: new Map(),\n      visible: new Map(),\n      ready: new Map(),\n      loading: false,\n    }\n\n    const { githubApiToken, type } = this.props\n\n    this.fetcher = new GithubFetcher(githubApiToken)\n\n    switch (type) {\n      case TYPES.REPO:\n        this.icon = <Icon type=\"book\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Repository\n        this.fetchCall = this.fetcher.fetchRepositoryData\n        break\n      case TYPES.STAR:\n        this.info = 'Star trend data are huge, they might take minutes to load.'\n        this.icon = <Icon type=\"star\" style={{ fontSize: '24px', color: '#ffb900' }} />\n        this.body = Star\n        this.fetchCall = this.fetcher.fetchStargazerData\n        break\n      case TYPES.FORK:\n        this.icon = <Icon type=\"fork\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Fork\n        this.fetchCall = this.fetcher.fetchForkData\n        break\n      case TYPES.COMMIT:\n        this.info = 'Because of the API restriction, only commits in a recent year will be loaded.'\n        this.icon = <Icon type=\"history\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Commit\n        this.fetchCall = this.fetcher.fetchCommitData\n        break\n      case TYPES.RELEASE:\n        this.icon = <Icon type=\"tag\" style={{ fontSize: '24px', color: '#333333' }} />\n        this.body = Release\n        this.fetchCall = this.fetcher.fetchReleaseData\n        break\n      default:\n        console.log('TYPE DOESNOT EXIST')\n        return 'ERROR'\n    }\n\n    // data formatter\n    this.formatter = this.body.formatter\n  }\n\n\n  componentDidUpdate(prevProps) {\n    const { deleteRepo, repos } = this.props\n    const { data, stats, progress, visible, loading, ready } = this.state\n\n    // delete repo out\n    if (deleteRepo !== prevProps.deleteRepo && deleteRepo !== '') {\n      data.delete(deleteRepo)\n      stats.delete(deleteRepo)\n      progress.delete(deleteRepo)\n      ready.delete(deleteRepo)\n      visible.delete(deleteRepo)\n      this.setState({ data, stats, progress, ready, visible, loading: this._getAllProgress() !== 100 && loading && repos.length !== 0 })\n    }\n\n    // new repo in\n    if (prevProps.repos !== repos && deleteRepo === '') {\n      const newRepo = repos.filter(repo => !prevProps.repos.includes(repo))\n      newRepo.forEach(repo => {\n        data.set(repo, {})\n        stats.set(repo, {})\n        progress.set(repo, 0)\n        ready.set(repo, false)\n        visible.set(repo, true)\n        this.setState({ data, stats, progress, ready, visible })\n        if (loading) {\n          this._fetch(repo)\n        }\n      })\n    }\n  }\n\n  /**\n   * fetching from a specific repository\n   * for a specific data type from DataTypes.js\n   * @param repo repo to fectch\n   * @returns exit status string\n   */\n  _fetch = repo => {\n    const { repos } = this.props\n    const slashIndex = repo.indexOf('/')\n    const owner = repo.slice(0, slashIndex)\n    const name = repo.slice(slashIndex + 1)\n\n    const onUpdate = data => {\n      if(this.state.data.has(repo)) {\n        this.state.data.set(\n          repo,\n          this.formatter ? this.formatter(repo, data) : data,\n        )\n        this.setState({ data: this.state.data })\n      }\n    }\n    const onFinish = stats => {\n      if(this.state.stats.has(repo)) {\n        this.state.stats.set(repo, stats)\n        this.state.ready.set(repo, true)\n        this.setState({ stats: this.state.stats, ready: this.state.ready})\n      }\n      if (this._getAllProgress() === 100) {\n        this.setState({ loading: false })\n      }\n    }\n    const onProgress = progress => {\n      if(this.state.progress.has(repo)) {\n        this.state.progress.set(repo,progress)\n        this.setState({\n          progress:this.state.progress\n        })\n      }\n    }\n    const shouldAbort = () => {\n      // if (this._getAllProgress() === 100) {\n      //   this.setState({ loading: false })\n      // }\n      return !repos.includes(repo)\n    }\n\n    this.fetchCall(\n      owner, name,\n      onUpdate,\n      onFinish,\n      onProgress,\n      shouldAbort,\n    )\n\n    return 'FETCH REQUESTED'\n  }\n\n  /**\n   * get progress of fetching all\n   * @returns progress as number from 0 to 100\n   */\n  _getAllProgress = () => {\n    const { progress } = this.state\n    return Math.floor(Array.from(progress.values()).reduce((a, b) => a + b, 0)\n    / (progress.size === 0 ? 1 : progress.size))\n  }\n\n  _renderUpdateAllButton = () => {\n    const { loading, ready } = this.state\n    const { repos } = this.props\n\n    return (\n      <Button\n        icon=\"cloud-download\"\n        type=\"link\"\n        disabled={repos.length === 0}\n        onClick={() => {\n          this.setState({ loading: true })\n          if (this._getAllProgress() === 100) { // re-fetch all\n            repos.forEach(repo => this._fetch(repo))\n          }\n          else { // on fetch unfetched\n            repos.forEach(repo => {\n              if (!ready.get(repo)) {\n                this._fetch(repo)\n              }\n            })\n          }\n        }}\n        loading={loading}\n      >\n        update\n      </Button>\n    )\n  }\n\n  _renderRepoTags = () => {\n    const { progress, visible } = this.state\n    const { repos } = this.props\n\n    return (\n      repos.map(repo => (\n        <div key={\"section-tag\" + repo} style={{ display: 'inline-block'}}>\n          <Progress\n            type=\"circle\"\n            percent={progress.get(repo)}\n            showInfo={false}\n            strokeWidth={8}\n            width={16}\n          />\n          <Tag\n            className=\"repo-tag\"\n            checked={visible.get(repo)}\n            onChange={checked => {\n              visible.set(repo, checked)\n              this.setState({ visible })\n            }}\n          >\n            {repo}\n          </Tag>\n        </div>\n      ))\n    )\n  }\n\n  _renderBody = () => {\n    const { data, stats, ready, loading } = this.state\n    const { repos } = this.props\n\n    return <this.body repos={repos} data={data} stats={stats} ready={ready} loading={loading}/>\n  }\n\n  render() {\n    const { type } = this.props\n\n    return (\n      <div id={type}>\n        <Row type=\"flex\" align=\"middle\" className=\"section-header\">\n          <div className=\"data-card\">\n            {this.icon}\n            <div className=\"section-title\">\n              {type}\n            </div>\n            {this.info ?\n              <Popover className=\"info-tag\" content={this.info} placement=\"left\">\n                <Icon type=\"info-circle\" />\n              </Popover> : null }\n          </div>\n          <div className=\"data-card\"  style={{ marginLeft: 'auto' }}>\n            {this._renderRepoTags()}\n          </div>\n          <Progress\n            type=\"circle\"\n            strokeWidth={4}\n            width={32}\n            percent={this._getAllProgress()}\n          />\n          <div className=\"data-card\">\n            {this._renderUpdateAllButton()}\n          </div>\n        </Row>\n        {this._renderBody()}\n      </div>\n    )\n  }\n\n}\n\nDataSection.propTypes = {\n  githubApiToken: PropTypes.string,\n  repos: PropTypes.array,\n  deleteRepo: PropTypes.string,\n  type: PropTypes.string,\n}\n\nconst mapStateToProps = state => ({\n  githubApiToken: state.github.githubApiToken\n})\n\nexport default connect(\n  mapStateToProps,\n)(DataSection)","import React from 'react'\nimport { connect } from 'react-redux'\nimport PropTypes from 'prop-types'\nimport _ from 'lodash'\n\nimport TYPES from './DataTypes'\nimport COLORS from './sections/Colors'\n\nimport { Row, Col, Anchor, Button, Tag, Tooltip, message, Select } from 'antd'\n\nimport DataSection from './DataSection'\n\nimport GithubFetcher from '../scripts/GithubFetcher'\n\nimport { updateState } from '../actions'\n\n// const CENTER_FLEX = { display: 'flex', placeContent: 'center' }\n// const CENTER_LEFT_FLEX = { display: 'flex', justifyContent: 'flex-start', alignContent: 'center'}\n\n// message.config({\n//   top: 60,\n//   duration: 2,\n//   maxCount: 5,\n// })\n\nclass GithubStatistics extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      repos:[],\n      input: undefined,\n      suggestions: [],\n      testingRepo: false,\n      deleteRepo: '',\n    }\n\n    this.fetcher = new GithubFetcher('05c1acf261f6b223411c73d8b71cb1a30ce9186a')\n\n    this.props.updateState(\"githubApiToken\", '05c1acf261f6b223411c73d8b71cb1a30ce9186a')\n\n    this.search = _.debounce(\n      this.fetcher.searchRepository,\n      300,\n      { leading: false, trailing: true }\n    ).bind(this)\n  }\n\n  deleteRepo = index => {\n    const { repos } = this.state\n    const deleteRepo = repos[index]\n    repos.splice(index,1)\n    this.setState({\n      repos: [...repos],\n      deleteRepo: deleteRepo,\n    })\n  }\n\n  addRepo = repo => {\n    const { repos } = this.state\n    if (repos.includes(repo)) {\n      message.error(`${repo} is already added`)\n    }\n    else {\n      this.setState({\n        repos: [ ...repos, repo],\n        deleteRepo: '',\n      })\n    }\n  }\n\n  // _handleAdding = repo => {\n  //   const slashIndex = repo.indexOf('/')\n  //   const owner = repo.slice(0, slashIndex)\n  //   const name = repo.slice(slashIndex + 1)\n\n  //   this.setState({ testingRepo: true })\n  //   this.fetcher.testRepository(owner, name,\n  //     result => {\n  //       this.setState({ testingRepo: false })\n  //       if (result) {\n  //         this.addRepo(repo)\n  //         message.success(repo + ' added')\n  //       } else {\n  //         message.error('Repository not found')\n  //       }\n  //     }\n  //   )\n  // }\n\n  _renderTags = () => {\n    const { repos } = this.state\n\n    return (\n      repos.map((repo, index) => (\n        <Tag key={\"tag\" + repo} color={COLORS[index]} closable onClose={() => this.deleteRepo(index)}>\n          <a target=\"_blank\" rel=\"noopener noreferrer\" href={`https://github.com/${repo}`}>{repo}</a>\n        </Tag>\n      ))\n    )\n  }\n\n  _renderHeaderInput = () => {\n    const { repos, input, testingRepo, suggestions } = this.state\n\n    // const format = /^[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}\\/{1}[a-z\\d](?:[a-z\\d]|-(?=[a-z\\d])){0,38}$/i\n\n    let hintMessage = ''\n\n    // Conditions\n    const inputEmpty = input === undefined\n    // const formatIncorrect = !format.test(input)\n    const repoExisted = repos.includes(input)\n\n    if (repoExisted) hintMessage = 'Repository already added'\n    // if (formatIncorrect) hintMessage = 'Input incorrectly formatted'\n    if (inputEmpty) hintMessage = 'Empty'\n\n    const disabled = inputEmpty || repoExisted\n\n    return (\n      <React.Fragment>\n        {/* <Input\n          className=\"header-input\"\n          prefix={<Icon type=\"github\"/>}\n          placeholder=\"owner/name\"\n          value={input}\n          onChange={e => {\n            this.setState({ input: e.target.value })\n            this.fetcher.searchRepository(e.target.value, suggestions => this.setState({ suggestions }))\n          }}\n          onPressEnter={() => !disabled && this._handleAdding(input)}\n          disabled={testingRepo}\n          allowClear\n        /> */}\n        <Select\n          className=\"header-input\"\n          value={input}\n          placeholder=\"search by repository\"\n          defaultActiveFirstOption={false}\n          onChange={input => {\n            this.setState({ input })\n            this.addRepo(input)\n          }}\n          onSearch={input => this.search(input, suggestions => this.setState({ suggestions }))}\n          notFoundContent={null}\n          showArrow={false}\n          filterOption={false}\n          showSearch\n        >\n          {suggestions.map(repo => (\n            <Select.Option key={`suggestion-${repo}`} value={repo}>{repo}</Select.Option>\n          ))}\n        </Select>\n        <Tooltip\n          title={hintMessage}\n        >\n          <Button\n            icon=\"plus\"\n            type=\"primary\"\n            loading={testingRepo}\n            disabled={disabled}\n            onClick={() => this.addRepo(input)}\n          />\n        </Tooltip>\n      </React.Fragment>\n    )\n  }\n\n  render() {\n    // const dotStyle = {strokeWidth: 2, r: 2.5}\n    const { repos, deleteRepo } = this.state\n\n    return (\n      <div>\n        <header className=\"header\">\n          <Row type=\"flex\" align=\"middle\">\n            <Col className=\"header-section\">\n              <a className=\"header-title\" href=\"/\">\n                Github Stats\n              </a>\n            </Col>\n            <iframe src=\"https://ghbtns.com/github-btn.html?user=vesoft-inc&repo=github-statistics&type=star&count=true\" frameBorder=\"0\" scrolling=\"0\" width=\"100px\" height=\"20px\" />\n            <Col className=\"header-section flex-center\">\n              {this._renderHeaderInput()}\n            </Col>\n            <Col className=\"header-section flex-center-left\">\n              {this._renderTags()}\n            </Col>\n          </Row>\n        </header>\n        <div className=\"container\">\n          <div className=\"sider\">\n            <Anchor bounds={0} className=\"anchor\">\n              {Object.values(TYPES).map(value => (\n                <Anchor.Link key={`anchor-link-${value}`} title={value} href={`#${value}`}/>\n              ))}\n            </Anchor>\n          </div>\n\n          <div className=\"content\" >\n            <DataSection\n              type={TYPES.REPO}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.STAR}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.FORK}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.COMMIT}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n\n            <DataSection\n              type={TYPES.RELEASE}\n              repos={repos}\n              deleteRepo={deleteRepo}\n            />\n          </div>\n        </div>\n\n        <footer className=\"footer\">\n        </footer>\n      </div>\n    )\n  }\n}\n\nGithubStatistics.propTypes = {\n  updateState: PropTypes.func,\n}\n\nconst mapDispatchToProps = dispatch => ({\n  updateState: (state, data) => dispatch(updateState(state, data)),\n})\n\nexport default connect(\n  null,\n  mapDispatchToProps,\n)(GithubStatistics)","export const updateState = (state, data) => ({\n  type: 'UPDATE_STATE',\n  payload: { state, data }\n})\n\nexport const updateStatsField = (state, stats) => ({\n  type: 'UPDATE_STATS_FIELD',\n  payload: { state, stats }\n})","import React from 'react'\nimport GithubStatistics from './GithubStatistics'\nimport '../css/App.css'\nclass App extends React.Component {\n  render() {\n    return (\n      <div>\n        <GithubStatistics />\n      </div>\n    )\n  }\n}\n\n\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport reducers from './reducers'\n\nimport './css/normalize.css'\nimport './css/index.css'\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\n\nconst store = createStore(reducers)\nReactDOM.render(\n  <React.Fragment>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.Fragment>\n  ,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}